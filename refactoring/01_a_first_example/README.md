# 1. 리팩터링: 첫 번째 예시
## 1.1 코드 설명
- 요청이 들어오면 장르와 관객 규모를 기초로 비용을 책정
- 장르는 1과 2
- 포인트를 지급하여 다음 비용 할인
## 1.2 예시 프로그램을 본 소감
- `statement_01.js`
- ex) 프로그램이 잘 작동하는 상황에서 미적 기준으로만 판단하는 것은 옳은가?
- 코드를 수정하려면 사람은 미적 상태에 민감하다.
- 설계가 나쁜 시스템은 수정하기 어렵다.
  - 수정해야 할 부분을 찾기 어렵다.
  - 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기 어렵다.
> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 
먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.

- ex) 유사한 기능의 추가가 필요한 경우 (HTML로 출력 등)
- 아마도 그 함수의 복사본을 만들고 복사본에서 HTML을 출력하는 식으로 처리할 것이다.
- 복사본을 만들어 수정하였을 때 많은 문제점이 발생한다.
  - 로직이 변경할 때마다 기존 함수와 HTML 출력 함수 모두를 수정해야한다.
  - 이들이 일관되게 수정되었는지 확인이 필요하다.
> 중복 코드는 골칫거리가 된다.

- **리팩터링이 필요한 이유는 변경 때문이다. 변경할 일이 절대 없다면 코드를 현재 상태로 놔둬도 문제없다.**
## 1.3 리팩터링의 첫 단계
- 항상 첫 단계는 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드를 마련하는 것. 수정 과정에서 예상치 못한 문제가 발생할 가능성이 크다.
- 테스트를 작성하는데 시간이 좀 걸리지만 신경 써서 만들어두면 오히려 디버깅 시간이 줄어서 전체 작업 시간은 오히려 단축된다.
> 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.
## 1.4 함수 쪼개기
- `switch`문을 살펴보면 공연에 대한 요금을 계산하고 있는데 이는 코드를 분석해서 얻은 정보이다.
- (**함수 추출하기(6.1)**) 코드 조각을 별도의 함수로 추출하는 방식으로 파악한 정보를 코드에 반영한다. 
- 새로 만들어진 함수에서 사용할 수 없는 변수가 발생하는지 확인한다. (예시에서 perf, play, thisAmount)
- 수정하고 나면 컴파일하고 테스트해서 실수한 게 없는지 확인한다.
> 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다.
그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

- 반환 값에는 항상 result라는 이름을 사용한다.
- 매개변수의 역할이 뚜렷하지 않을 때는 부정 관사 (a/an)을 붙인다.
> 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다.
- play 변수 제거하기
  - 임시 변수들은 로컬 범위에 존재하는 이름이 늘어나서 추출 작업이 복잡해진다.
  - **임시 변수를 질의 함수로 바꾼다.(7.4)**
  - **변수 인라인하기(6.4)**를 적용한다.
  - **함수 선언 바꾸기(6.5)**를 적용한다.
  - 필요없는 매개변수를 제거한다.
- 적립 포인트 계산 코드 추출하기
- format 변수 제거하기(**함수 이름 변경**)
  - 함수 변수를 일반 함수로 변경하는 것도 리팩터링
  - 함수의 이름은 함수가 하는 일을 충분히 설명해야한다.
  - 템플릿 문자열 안에서 사용될 이름에(가시 범위가 좁다면) 너무 장황한 이름은 피한다.
  - 함수의 핵심 의미에 대한 느낌을 살리는 이름을 찾는다.
- volumeCredits 변수 제거하기
  - **반복문 쪼개기(8.7)**를 통해 별도의 for문으로 분리한다
  - **문장 슬라이스하기(6.8)**를 적용하여 변수를 선언하는 문장을 반복문 앞으로 옮긴다.
  - **임시 변수를 질의 함수로 바꾸기**와 **함수 추출하기**를 수행한다.
  - **변수 인라인하기**로 volumeCredits 변수를 제거한다.
  - 반복문을 쪼개면 성능이 느려질 걱정을 할 수 있지만 리팩터링 과정에서 성능이 크게 떨어졌다면 리팩터링 후 시간을 내어 성능을 개선한다.
- totalAmount 변수 제거하기
## 1.5 중간 점검1
- `statement_02.js`
## 1.6 계산 단계와 포맷팅 단계 분리하기
- 기능 변경 HTML 출력 버전을 만드는 작업
- **단계 쪼개기(6.11)** 
  - 단계를 쪼개기 위해서 **함수 추출하기**를 수행한다.
  - 인수를 통해 전달되는 데이터를 중간 데이터 구조로 옮긴다.
- **반복문을 파이프라인으로 바꾸기(8.8)**
## 1.7 중간점검2
- `statement_03.js`
## 1.8 다형성을 활용해 계산 코드 재구성하기
- `statement_04.js`
- **조건부 로직을 다형성으로 바꾸기(10.4)**
  - **상속 계층부터 정의**해야한다.
- 공연료 계산기 만들기
  - PerformanceCalculator
  - **함수 선언 바꾸기**
- 함수들을 계산기로 옮기기
  - **함수 옮기기(8.1)**를 통해 기존 함수를 클래스로 옮긴다.
  - 복사한 함수가 동작하게 수정했다면 원본 함수가 방금 만든 함수로 작업을 위임하도록 수정한다.
  - 코드가 작동하는지 확인하고 문제없다면 원래 함수를 인라인하여 새 함수를 직접 호출하도록 수정한다
- 공연료 계산기를 다형성 버전으로 만들기
  - **타입 코드를 서브클래스로 바꾸기(12.6)**
  - **생성자를 팩터리 함수로 바꾸기(11.8)**
    - 자바스크립트에서는 생성자가 서브클래스의 인스턴스를 반환할 수 없다.
  - **조건부 로직을 다형성으로 바꾸기(10.4)** 적용
## 1.9 상태 점검: 다형성을 활용하여 데이터 생산하기
- 연극 장르별 계산 코드들을 함께 묶었다
- 새로운 장르를 추가하려면 해당 장르의 서브클래스를 작성하고 생성 함수인 `createPerformanceCalculator()`에 추가하기만 하면 된다.
- 같은 타입의 다형성을 기반으로 실행되는 함수가 많을수록 유리하다.
## 1.10 마치며
- 진행단계
  - 원본 함수를 중첩 함수 여러 개로 나누었다.
  - 단계 쪼개기를 적용해서 계산 코드와 출력 코드를 분리했다.
  - 계산 로직을 다형성으로 표현했다.
  - 각 단계에서 코드 구조를 보강했고, 그럴 때마다 코드가 수행하는 일이 더욱 분명하게 드러났다.
- 리팩터링은 코드가 하는 일을 파악하는 데서 시작한다. 코드를 읽고, 개선점을 찾고, 리팩터링 작업을 통해 개선점을 코드에 반영하는 식으로 진행한다.
> 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.
- 코드는 명확해야 한다. 수정해야 할 상황이 오면 고쳐야 할 곳을 쉽게 찾을 수 있고 오류 없이 빠르게 수정할 수 있어야 한다.
- 건강한 코드베이스는 생산성을 극대화한다.
