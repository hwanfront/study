# 3. 코드에서 나는 악취
- 리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 중요하다.
## 3.1 기이한 이름 Mysterious Name
- 함수, 모듈, 변수, 클래스 등 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 이름을 지어야 한다.
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.
## 3.2 중복 코드 Duplicated Code
- 똑같은 코드 구조가 반복된다면 하나로 통합한다. 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야 한다.
## 3.3 긴 함수 Long Function
- 함수를 짧게 구성하면 코드를 이해하고, 공유하고, 선택하기 쉬워진다.
- 함수 이름을 잘 지어두면 본문 코드를 볼 이유는 사라진다. 그러기 위해서 적극적으로 함수를 쪼개야 한다.
- 함수 이름은 동작 방식이 아닌 의도 intention 가 드러나게 짓는다.
- 함수를 짧게 만드는 작업은 대부분 **함수 추출하기(6.1)**
- 임시변수나 매개변수가 많다면
  - **임시변수를 질의 함수로 바꾸기(7.4)**
  - **매개변수 객체 만들기(6.8)**
  - **객체 통째로 넘기기(11.4)**
- 조건문이나 반복문
  - **조건문 분해하기(10.1)**
  - switch문의 case문마다 **함수 추출하기(6.1)**
  - **조건문을 다형성으로 바꾸기(10.4)**
  - 반복문 코드 추출해서 독립된 함수로 만들기 
  - 적합한 이름이 떠오르지 않는다면 **반복문 쪼개기(8.7)**
## 3.4 긴 매개변수 목록 Long Parameter List
- 매개변수 목록이 길어지면 그 자체로 이해하기 어렵다.
## 3.5 전역 데이터 Global Data
- 전역 변수만이 아닌 클래스 변수와 싱글톤에서도 같은 문제 발생
- **변수 캡슐화하기(6.6)**
- 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있다.
- 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다.
## 3.6 가변 데이터 Mutable Data
- 무분별한 데이터 수정에 따른 위험성을 줄인다.
- **변수 캡슐화하기(6.6)**를 적용하여 함수를 거쳐야 값을 수정할 수 있도록 한다.
## 3.7 뒤엉킨 변경 Divergent Change
- 단일 책임 원칙 Single Responsibility Principle 이 제대로 지켜지지 않을 때 나타난다.
## 3.8 산탄총 수술 Shotgun Surgery
- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 나타난다.
## 3.9 기능 편애 Feature Envy
- 프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 
- 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주룍한다.
- 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 많을 때 나타난다.
- 디자인 패턴의 전략 패턴 Strategy Pattern과 방문자 패턴 Vissitor Pattern, 자기 위임 Self-Delegation 의 기본 원칙은 '함께 변경할 대상을 한데 모으는 것'
## 3.10 데이터 뭉치 Data Clumps
- 데이터 항목 서너개가 여러 곳에서 항상 뭉쳐있는 모습
- 클래스 두어 개의 필드 혹은 여러 메서드의 시그니처에서 함께 발견되고 이 데이터 뭉치들을 클래스로 추출한다.
## 3.11 기본형 집착 Primitive Obsession
- 보통 문자열을 다루는 코드에서 흔하며 화폐, 좌표, 구간 등 기초 타입을 직접 정의하지 않는 경우에 나타난다.
## 3.12 반복되는 switch문 Repeated Switches
- 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 수정해야 하는 문제
- 다형성은 반복된 switch문을 세련되게 수정할 수 있다.
## 3.13 반복문 Loops
- 일급 함수를 지원하는 언어가 많아졌고 파이프라인으로 반복문을 제거할 수 있게 되었다.
## 3.14 성의 없는 요소 Lazy Element
- 함수(메서드), 클래스, 인터페이스 등 코드 구조를 잡는데 활용되는 요소가 필요 없는 경우 제거하는 게 좋다.
## 3.15 추측성 일반화 Speculative Generality
- 나중에 필요할것이라는 생각으로 당장은 필요 없는 후킹 포인트나 특이 케이스 처리 로직을 작성해둔 코드에서 나타난다.
- 당장 걸리적거리는 코드는 치우는 게 좋다.
## 3.16 임시 필드 Temporary Field
- 특정 상황에서만 값이 설정되는 필드를 가진 클래스, 임시 필드를 갖도록 코드를 작성해두었을 때 나타난다.
## 3.17 메시지 체인 Message Chains
- 메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.
- 클라이언트가 객체 내비게이션 구조에 종속되는 경우에 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.
## 3.18 중개자 Middle Man
- 객체의 대표적인 기능, 외부로부터 세부사항을 숨겨주는 캡슐화가 있다. 캡슐화 과정에서는 위임이 자주 활용된다.
- 지나치면 문제가 된다. 클래스가 제공하는 메서드가 다른 클래스에 구현을 위임하고 있다면 실제로 일을 하는 객체와 직접 소통하게 한다.
## 3.19 내부자 거래 Insider Trading
- 모듈 사이의 데이터 거래를 줄여 결합도를 낮추고, 관심사를 공유한다면 공통 부분을 처리하는 다른 모듈이 중간자 역할을 하게 만든다.
## 3.20 거대한 클래스 Large Class
- 클래스에 필드가 많으면 중복 코드가 생기기 쉽다.
- 코드량이 너무 많은 클래스 또한 중복 코드와 혼동을 일으키기 쉽다. 클래스 안에서 자체 중복을 제거한다.
## 3.21 서로 다른 인터페이스의 대안 클래스들 Alternative Classes with Different Interfaces
- 클래스의 큰 장점은 필요에 따라 다른 클래스로 교체할 수 있다는 점. 교체를 하려면 인터페이스가 같아야 한다.
## 3.22 데이터클래스 Data Class
- 데이터 클래스란 데이터 필드와 getter/setter로만 구성된 클래스
- public 필드는 숨기자
- 필요한 동작이 엉뚱한 곳에 정의돼 있을 수 있다.
- 불변 필드는 굳이 캡슐화할 필요가 없다.
## 3.23 상속 포기 Refused Bequest
- 서브클래스는 부모로부터 메서드와 데이터를 물려받지만 관심 있는 일부만 필요할 경우
- 예전에는 계층 구조를 잘못 설계했기 때문으로 보았다.
  - 같은 계층 서브클래스를 새로 만들고 물려받지 않을 부모 코드를 모조리 새로 만든 서브클래스로 넘긴다.
- 상속을 포기할 시 문제가 생긴다면 예전 방식을 따를만 하다. 무조건은 아님.
- 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 나타난다.
  - 인터페이스를 따르지 않는다는 것은 상당히 무례한 태도
## 3.24 주석 Comments
- 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 많다.
- 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.
